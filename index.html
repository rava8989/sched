<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Pure Schedule</title>

<style>
:root{
  --grid:#6a6a6a;

  /* darkness scale */
  --hdr9:#1a1a1a;   /* header row = 9/10 on WEEKDAYS only */
  --sun7:#4d4d4d;   /* Sunday column = 7/10 */
  --sat5:#7a7a7a;   /* Saturday column = 5/10 */
  --wk:#f6f6f6;     /* weekday column base */

  /* row striping (weekdays only; NEVER overrides weekend columns) */
  --row2:#e6e6e6;   /* first person row */
  --row1:#f0f0f0;   /* second person row */

  --holiday:#b30000;
}

body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; background:#fff; }

header{
  position:sticky; top:0; z-index:20;
  background:#fff;
  border-bottom:2px solid var(--grid);
  padding:8px;
}

.controls{
  display:flex; gap:8px; flex-wrap:wrap; align-items:center;
}

select,input,button{
  padding:6px 8px;
  font-size:14px;
  border:2px solid var(--grid);
  border-radius:8px;
  background:#fff;
}

button{cursor:pointer}

.wrap{ padding:8px; }

.panel{
  border:2px solid var(--grid);
  border-radius:10px;
  margin-bottom:12px;
  overflow:hidden;
}

.monthHeader{
  background:var(--hdr9);
  color:#fff;
  padding:8px 12px;
  font-weight:900;
  text-transform:uppercase;
  font-size:14px;
}

.scroll{
  overflow-x:auto;
  -webkit-overflow-scrolling:touch;
}

table{
  border-collapse:collapse;
  font-family:ui-monospace,Menlo,Consolas,monospace;
  font-size:12px;
  width:max-content;
  min-width:100%;
}

th,td{
  border:1px solid var(--grid);
  text-align:center;
  padding:0;
  height:28px;
  min-width:34px;
  font-weight:900;
}

th.name, td.name{
  position:sticky;
  left:0;
  z-index:6;
  text-align:left;
  padding:0 8px;
  min-width:190px;
  font-family:system-ui;
  font-weight:900;
}

/* Column colors for BODY */
.wkCol{ background:var(--wk) !important; color:#111; }
.satCol{ background:var(--sat5) !important; color:#111; }
.sunCol{ background:var(--sun7) !important; color:#fff; }

/* Row striping affects ONLY weekday cells (never sat/sun) */
tr.r2 td.wkCol{ background:var(--row2) !important; }
tr.r1 td.wkCol{ background:var(--row1) !important; }
tr.r2 td.name{ background:var(--row2) !important; }
tr.r1 td.name{ background:var(--row1) !important; }

/* Header rows:
   - weekdays: 9/10 dark
   - weekends: keep weekend shades
*/
tr.hdrRow th.wkCol{ background:var(--hdr9) !important; color:#fff !important; }
tr.hdrRow th.satCol{ background:var(--sat5) !important; color:#111 !important; }
tr.hdrRow th.sunCol{ background:var(--sun7) !important; color:#fff !important; }
tr.hdrRow th.name{ background:var(--hdr9) !important; color:#fff !important; }

/* HOL red text (background stays column/row shaded) */
td.hol{ color:var(--holiday) !important; font-weight:1000; }

td.empty{ color:transparent !important; }

@media (max-width:700px){
  th.name, td.name{ min-width:150px; }
  table{ font-size:11px; }
}
</style>
</head>

<body>
<header>
  <div class="controls">
    <label>Start Month
      <input id="startMonth" type="month">
    </label>

    <label>Show Months
      <select id="showMonths">
        <option value="3">3</option>
        <option value="4">4</option>
      </select>
    </label>

    <button id="prev">◀</button>
    <button id="next">▶</button>
    <button id="today">This Month</button>
  </div>
</header>

<div class="wrap" id="wrap"></div>

<script>
/* ================= BASE DATA ================= */

const ANCHOR = "2026-01-01";
const LOOP = 42;

const SLOTS = {
1:["R","R","RDO","RDO","RDO","MDO","C","C/A","C","C","C","C","RDO","RDO","B","B","B","B","B","B","RDO","RDO","A","A","A","A","A/C","A","MDO","RDO","RDO","RDO","B","B","B","B","B","RDO","RDO","R","R","R"],
2:["C/A","C","C","C","C","RDO","RDO","B","B","B","B","B","B","RDO","RDO","A","A","A","A","A/C","A","MDO","RDO","RDO","RDO","B","B","B","B","B","RDO","RDO","R","R","R","R","R","RDO","RDO","RDO","MDO","C"],
3:["B","B","B","B","B","B","RDO","RDO","A","A","A","A","A/C","A","MDO","RDO","RDO","RDO","B","B","B","B","B","RDO","RDO","R","R","R","R","R","RDO","RDO","RDO","MDO","C","C/A","C","C","C","C","RDO","RDO"],
4:["RDO","A","A","A","A","A/C","A","MDO","RDO","RDO","RDO","B","B","B","B","B","RDO","RDO","R","R","R","R","R","RDO","RDO","RDO","MDO","C","C/A","C","C","C","C","RDO","RDO","B","B","B","B","B","B","RDO"],
5:["MDO","RDO","RDO","RDO","B","B","B","B","B","RDO","RDO","R","R","R","R","R","RDO","RDO","RDO","MDO","C","C/A","C","C","C","C","RDO","RDO","B","B","B","B","B","B","RDO","RDO","A","A","A","A","A/C","A"],
6:["B","B","RDO","RDO","R","R","R","R","R","RDO","RDO","RDO","MDO","C","C/A","C","C","C","C","RDO","RDO","B","B","B","B","B","B","RDO","RDO","A","A","A","A","A/C","A","MDO","RDO","RDO","RDO","B","B","B"]
};

const PEOPLE=[
 {n:"Kingston, Joseph C.",s:1},
 {n:"Rodriguez, Roger",s:1},
 {n:"Joseph, George R",s:2},
 {n:"Ramnarine, Ashram",s:2},
 {n:"Segovia, Eduardo M",s:3},
 {n:"Victoria, Robert",s:3},
 {n:"Bouaziz, Abdelghani",s:4},
 {n:"Gragossian, Alan",s:4},
 {n:"Handel, Joseph",s:5},
 {n:"Rakhmanov, Ravshan",s:5},
 {n:"Rodriguez, Alexander",s:6},
 {n:"Svenjak, Mark",s:6}
];

/* Your holiday list (month-day). We apply it to any year shown. */
const HOLIDAY_MD = ["01-01","01-20","02-17","05-26","06-19","06-03","06-06","09-01","10-13","11-11","11-27","11-28","12-25"];

/* ================= UTIL ================= */

const pad=n=>String(n).padStart(2,"0");
const iso=d=>`${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
const idx=i=>((i%LOOP)+LOOP)%LOOP;

function baseCode(slot, date){
  const a=new Date(ANCHOR);
  const di=Math.floor((date-a)/86400000);
  return SLOTS[slot][idx(di)];
}
function getBase(p, date){ return baseCode(p.s, date); }

function colClassForDow(w){
  if(w===0) return "sunCol";
  if(w===6) return "satCol";
  return "wkCol";
}
function isWeekend(d){ const w=d.getDay(); return w===0 || w===6; }
function isWeekday(d){ const w=d.getDay(); return w>=1 && w<=5; }
function isDoubleCode(code){ return String(code).includes("/"); }
function isWorkingAC(code){
  // A, C, doubles like C/A, A/C count as working on the holiday day
  if(code==="A" || code==="C") return true;
  if(isDoubleCode(code)) return true;
  return false;
}
function isOffCode(code){ return code==="RDO" || code==="MDO"; }
function isReserve(code){ return code==="R"; }

/* Contiguous B-run includes weekend? */
function bRunIncludesWeekend(p, date){
  const code = getBase(p, date);
  if(code!=="B") return false;

  // scan within +/- 10 days to cover the B block
  let start = new Date(date);
  for(let i=0;i<10;i++){
    const prev = new Date(start); prev.setDate(prev.getDate()-1);
    if(getBase(p, prev)!=="B") break;
    start = prev;
  }
  let end = new Date(date);
  for(let i=0;i<10;i++){
    const nxt = new Date(end); nxt.setDate(nxt.getDate()+1);
    if(getBase(p, nxt)!=="B") break;
    end = nxt;
  }

  // does this B block include a Sat or Sun?
  let cur = new Date(start);
  while(cur <= end){
    const w = cur.getDay();
    if(w===0 || w===6) return true;
    cur.setDate(cur.getDate()+1);
  }
  return false;
}

/* Build holiday set for years we might display */
function buildHolidaySetForYears(years){
  const s=new Set();
  for(const y of years){
    for(const md of HOLIDAY_MD){
      s.add(`${y}-${md}`);
    }
  }
  return s;
}

/* ================= HOLIDAY WORK + HOL DAY PLACEMENT (24/7 coverage) =================

Rules implemented:

- A/C (and doubles) ALWAYS WORK the holiday on that date; they do NOT show HOL on that date.
  They receive a HOL day placed on their first weekday B after the holiday (Mon-Fri, base=B, not weekend, not R).
- If holiday falls on RDO/MDO => it does NOT disappear. It moves to next weekday B as HOL.
- B coverage:
    * If holiday on weekend: whoever is base B that day works (normally your 2 guys).
    * If holiday on weekday:
        - Mon/Tue/Thu/Fri: the two B workers whose B-run includes the weekend work (Thu-Tue group).
        - Wednesday: the two B workers whose B-run does NOT include weekend work (Mon-Fri group).
      B workers not selected get HOL on that holiday date (red HOL), because they are off that holiday.
- Everyone who WORKS holiday earns 1 HOL credit to be placed later (next weekday B).
  Everyone who is OFF because holiday landed on RDO/MDO earns 1 HOL credit to be placed later.
  B workers who are OFF because not selected use the holiday THAT DAY (HOL on the date) and do not get a later credit.
*/

function computeDisplayForRange(rangeStart, rangeEnd){
  // Determine years in range to build holiday list
  const years=new Set();
  let tmp=new Date(rangeStart);
  while(tmp <= rangeEnd){
    years.add(tmp.getFullYear());
    tmp.setDate(tmp.getDate()+1);
  }
  const HOL = buildHolidaySetForYears([...years]);

  // Precompute base map per person per date
  const baseMapByPerson = new Map(); // name -> Map(iso -> code)
  for(const p of PEOPLE){
    const m=new Map();
    let d=new Date(rangeStart);
    while(d <= rangeEnd){
      m.set(iso(d), getBase(p, d));
      d.setDate(d.getDate()+1);
    }
    baseMapByPerson.set(p.n, m);
  }

  // Track HOL placed on a date (for each person)
  const holOnDate = new Map(); // name -> Set(iso)
  const holCredits = new Map(); // name -> number of credits to place later
  for(const p of PEOPLE){
    holOnDate.set(p.n, new Set());
    holCredits.set(p.n, 0);
  }

  // helper: place 1 credit on next valid weekday base-B (not weekend, not R), skipping already HOL
  function placeNextCredit(pName, fromISO){
    const baseM = baseMapByPerson.get(pName);
    const holS = holOnDate.get(pName);

    let d=new Date(fromISO);
    // start searching the next day
    d.setDate(d.getDate()+1);

    for(let i=0;i<90;i++){
      const di=iso(d);
      const code=baseM.get(di) || "";
      if(isWeekday(d) && code==="B" && !isReserve(code) && !holS.has(di)){
        holS.add(di);
        return true;
      }
      d.setDate(d.getDate()+1);
    }
    return false;
  }

  // Determine B workers who WORK the holiday on a given holiday weekday
  function pickBWorkersForHoliday(holidayDate){
    const w = holidayDate.getDay();

    // candidates base B on that date
    const candidates = PEOPLE.filter(p => (baseMapByPerson.get(p.n).get(iso(holidayDate)) === "B"));

    // weekend holiday -> whoever is B works (usually 2)
    if(isWeekend(holidayDate)){
      return new Set(candidates.map(p=>p.n));
    }

    // weekday holiday -> pick exactly 2
    const needWeekendGroup = (w===1 || w===2 || w===4 || w===5); // Mon Tue Thu Fri
    const needWeekGroup   = (w===3); // Wed

    const groupMatch = [];
    const groupOther = [];

    for(const p of candidates){
      const includesWeekend = bRunIncludesWeekend(p, holidayDate);
      if(needWeekGroup){
        // Wed: prefer B runs that do NOT include weekend
        (includesWeekend ? groupOther : groupMatch).push(p);
      } else if(needWeekendGroup){
        // Mon/Tue/Thu/Fri: prefer B runs that DO include weekend
        (includesWeekend ? groupMatch : groupOther).push(p);
      } else {
        groupMatch.push(p);
      }
    }

    const sorted = (arr)=>arr.slice().sort((a,b)=> (a.s-b.s) || a.n.localeCompare(b.n));

    const pick=[];
    for(const p of sorted(groupMatch)){ if(pick.length<2) pick.push(p); }
    for(const p of sorted(groupOther)){ if(pick.length<2) pick.push(p); }

    return new Set(pick.map(p=>p.n));
  }

  // Process holidays chronologically
  const holidayISOs = [];
  let d=new Date(rangeStart);
  while(d <= rangeEnd){
    const di=iso(d);
    if(HOL.has(di)) holidayISOs.push(di);
    d.setDate(d.getDate()+1);
  }

  for(const hISO of holidayISOs){
    const hDate=new Date(hISO);
    const bWorkers = pickBWorkersForHoliday(hDate);

    for(const p of PEOPLE){
      const baseM = baseMapByPerson.get(p.n);
      const code = baseM.get(hISO) || "";

      // If off (RDO/MDO): holiday moves -> credit later
      if(isOffCode(code)){
        holCredits.set(p.n, holCredits.get(p.n)+1);
        continue;
      }

      // A/C/doubles: they work holiday -> credit later
      if(isWorkingAC(code)){
        holCredits.set(p.n, holCredits.get(p.n)+1);
        continue;
      }

      // Reserve "R": treat as normal B tour BUT HOL cannot be placed on R day.
      // If holiday lands on R, treat as "worked holiday" for coverage -> credit later.
      if(isReserve(code)){
        holCredits.set(p.n, holCredits.get(p.n)+1);
        continue;
      }

      // B logic
      if(code==="B"){
        if(bWorkers.has(p.n)){
          // works holiday -> credit later
          holCredits.set(p.n, holCredits.get(p.n)+1);
        } else {
          // off holiday that day -> HOL shown on the holiday date (no later credit)
          holOnDate.get(p.n).add(hISO);
        }
        continue;
      }

      // Anything else: default to working holiday -> credit later
      holCredits.set(p.n, holCredits.get(p.n)+1);
    }

    // After assigning credits for this holiday, place them for each person as soon as possible.
    // This matches "first B weekday they have" after the holiday.
    for(const p of PEOPLE){
      let c = holCredits.get(p.n);
      while(c > 0){
        const placed = placeNextCredit(p.n, hISO);
        if(!placed) break;
        c--;
      }
      holCredits.set(p.n, c);
    }
  }

  // Build final display map per person per date (HOL overrides text)
  const displayByPerson = new Map(); // name -> Map(iso -> displayText)
  for(const p of PEOPLE){
    const baseM=baseMapByPerson.get(p.n);
    const holS=holOnDate.get(p.n);
    const dispM=new Map();
    let dd=new Date(rangeStart);
    while(dd <= rangeEnd){
      const di=iso(dd);
      dispM.set(di, holS.has(di) ? "HOL" : (baseM.get(di)||""));
      dd.setDate(dd.getDate()+1);
    }
    displayByPerson.set(p.n, dispM);
  }

  return { displayByPerson, baseMapByPerson, HOL };
}

/* ================= RENDER ================= */

const wrap=document.getElementById("wrap");

// default Jan 2026
let start = new Date(2026,0,1);
start.setDate(1);

function setMonthInput(){
  document.getElementById("startMonth").value = `${start.getFullYear()}-${pad(start.getMonth()+1)}`;
}

function render(){
  wrap.innerHTML="";
  const show=+document.getElementById("showMonths").value;

  // Range for display+holiday placement (12 months ahead + buffer)
  const rangeStart = new Date(start.getFullYear(), start.getMonth(), 1);
  const rangeEnd = new Date(start.getFullYear(), start.getMonth()+12, 1);
  rangeEnd.setDate(rangeEnd.getDate()+90);

  const computed = computeDisplayForRange(rangeStart, rangeEnd);

  for(let m=0;m<show;m++){
    drawMonth(new Date(start.getFullYear(), start.getMonth()+m, 1), computed);
  }
}

function drawMonth(d, computed){
  const y=d.getFullYear(), m=d.getMonth();
  const dim=new Date(y,m+1,0).getDate();
  const MAX_DAYS = 31; // symmetric month tables

  const panel=document.createElement("div");
  panel.className="panel";

  const header=document.createElement("div");
  header.className="monthHeader";
  header.textContent = `${d.toLocaleString("default",{month:"long"})} ${y}`;
  panel.appendChild(header);

  const sc=document.createElement("div");
  sc.className="scroll";

  const t=document.createElement("table");

  // Header row: day numbers (symmetric 31 columns)
  let tr=document.createElement("tr");
  tr.className="hdrRow";
  tr.innerHTML = `<th class="name">NAME</th>`;
  for(let day=1; day<=MAX_DAYS; day++){
    if(day<=dim){
      const dt=new Date(y,m,day);
      const cls=colClassForDow(dt.getDay());
      tr.innerHTML += `<th class="${cls}">${day}</th>`;
    } else {
      // empty column, keep as weekday style
      tr.innerHTML += `<th class="wkCol"></th>`;
    }
  }
  t.appendChild(tr);

  // Header row: DOW
  tr=document.createElement("tr");
  tr.className="hdrRow";
  tr.innerHTML = `<th class="name"></th>`;
  const dows=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
  for(let day=1; day<=MAX_DAYS; day++){
    if(day<=dim){
      const dt=new Date(y,m,day);
      const cls=colClassForDow(dt.getDay());
      tr.innerHTML += `<th class="${cls}">${dows[dt.getDay()]}</th>`;
    } else {
      tr.innerHTML += `<th class="wkCol"></th>`;
    }
  }
  t.appendChild(tr);

  // People rows (striping applies to weekday cells only)
  PEOPLE.forEach((ppl, i)=>{
    const r=document.createElement("tr");
    r.className = (i%2===0) ? "r2" : "r1";

    r.innerHTML = `<td class="name">${ppl.n}</td>`;

    const dispM = computed.displayByPerson.get(ppl.n);
    const baseM = computed.baseMapByPerson.get(ppl.n);

    for(let day=1; day<=MAX_DAYS; day++){
      if(day<=dim){
        const dt=new Date(y,m,day);
        const cls = colClassForDow(dt.getDay());
        const di = iso(dt);

        const display = dispM.get(di) || "";
        const baseCode = baseM.get(di) || "";

        const td=document.createElement("td");
        td.className = cls;
        td.dataset.code = baseCode;

        if(display === "HOL"){
          td.classList.add("hol");
          td.textContent = "HOL";
        } else {
          td.textContent = baseCode;
        }

        r.appendChild(td);
      } else {
        const td=document.createElement("td");
        td.className="wkCol empty";
        td.textContent=".";
        r.appendChild(td);
      }
    }
    t.appendChild(r);
  });

  sc.appendChild(t);
  panel.appendChild(sc);
  wrap.appendChild(panel);
}

/* ================= CONTROLS ================= */

document.getElementById("showMonths").addEventListener("change", ()=>{ setMonthInput(); render(); });

document.getElementById("startMonth").addEventListener("change", (e)=>{
  start = new Date(e.target.value + "-01");
  start.setDate(1);
  setMonthInput();
  render();
});

document.getElementById("prev").addEventListener("click", ()=>{
  start.setMonth(start.getMonth()-1);
  start.setDate(1);
  setMonthInput();
  render();
});

document.getElementById("next").addEventListener("click", ()=>{
  start.setMonth(start.getMonth()+1);
  start.setDate(1);
  setMonthInput();
  render();
});

document.getElementById("today").addEventListener("click", ()=>{
  start = new Date();
  start.setDate(1);
  setMonthInput();
  render();
});

setMonthInput();
render();
</script>
</body>
</html>
